diff --git a/a/astropy/modeling/separable.py b/b/astropy/modeling/separable.py
--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py
@@
-from .core import Model, CompoundModel
+from .core import Model, CompoundModel
import numpy as np
@@
-def separability_matrix(model):\n-    \"\"\"\n-    Returns a boolean matrix stating whether each output of a model depends on\n-    each input. The entry (i, j) is True if output i depends on input j.\n-\n-    Parameters\n-    ----------\n-    model : `~astropy.modeling.Model`\n-        The model for which to calculate the separability matrix.\n-\n-    Returns\n-    -------\n-    matrix : `~numpy.ndarray`\n-        A boolean array with shape (n_outputs, n_inputs).\n-    \"\"\"\n-    n_inputs = len(model.inputs)\n-    n_outputs = len(model.outputs)\n-\n-    # Initialize matrix with False\n-    matrix = np.zeros((n_outputs, n_inputs), dtype=bool)\n-\n-    # For each output, determine which inputs it depends on\n-    for i, out_name in enumerate(model.outputs):\n-        # Find all the inputs that affect this output by checking the dependencies\n-        # defined in the model's ``depends_on`` attribute. This attribute maps each\n-        # output name to a set of input names it depends on.\n-        deps = model.depends_on.get(out_name, set())\n-\n-        for j, in_name in enumerate(model.inputs):\n-            matrix[i, j] = in_name in deps\n-\n-    return matrix\n+def separability_matrix(model):\n+    \"\"\"\n+    Returns a boolean matrix stating whether each output of a model depends on\n+    each input. The entry (i, j) is True if output i depends on input j.\n+\n+    This implementation correctly handles nested ``CompoundModel`` objects\n+    that are created using the ``&`` (join) operator.\n+    \"\"\"\n+    # Base case: simple models (including non-joined CompoundModels)\n+    if not isinstance(model, CompoundModel) or getattr(model, \"operation\", None) != \"join\":\n+        n_inputs = len(model.inputs)\n+        n_outputs = len(model.outputs)\n+        matrix = np.zeros((n_outputs, n_inputs), dtype=bool)\n+        for i, out_name in enumerate(model.outputs):\n+            deps = model.depends_on.get(out_name, set())\n+            for j, in_name in enumerate(model.inputs):\n+                matrix[i, j] = in_name in deps\n+        return matrix\n+\n+    # Recursive case: a CompoundModel created via the ``&`` (join) operator.\n+    # Decompose into left and right sub\u2011models and build a block\u2011diagonal matrix.\n+    left, right = model.left, model.right\n+\n+    left_mat = separability_matrix(left)\n+    right_mat = separability_matrix(right)\n+\n+    # Determine shapes\n+    n_out_left, n_in_left = left_mat.shape\n+    n_out_right, n_in_right = right_mat.shape\n+\n+    # Construct block\u2011diagonal matrix\n+    top = np.hstack([left_mat, np.zeros((n_out_left, n_in_right), dtype=bool)])\n+    bottom = np.hstack([np.zeros((n_out_right, n_in_left), dtype=bool), right_mat])\n+    return np.vstack([top, bottom])\n*** End of File ***